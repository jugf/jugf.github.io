<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Events on Main</title><link>http://jugf.github.io/posts/</link><description>Recent content in Events on Main</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Java User Group Frankfurt</copyright><lastBuildDate>Tue, 17 Oct 2023 00:00:00 +0100</lastBuildDate><atom:link href="http://jugf.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>28.02.2024: IDEasy &amp; GraalVM – Automatisierung der IDE</title><link>http://jugf.github.io/posts/ideasy-automatisierung-der-ide-28-02-2024/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/ideasy-automatisierung-der-ide-28-02-2024/</guid><description>Stell dir vor Michael Schuhmacher wäre auf die Rennpiste gekommen und statt seinem Formel1-Wagen wären da lauter Einzelteile und Werkzeuge&amp;hellip; Unvorstellbar – aber so sieht oft der Projektalltag für Entwickler aus, die neu ins Projekt kommen und die Entwicklungsumgebung einrichten müssen.
Entwicklerwerkzeuge müssen nicht nur in der richtigen Version heruntergeladen und installiert werden, sondern auch passend für das Projekt konfiguriert werden. Bis alles passt und Diff-Wars verhindert sind, vergehen da Tage – manchmal sogar Wochen.</description></item><item><title>31.01.2024: Todesursache: Hibernate</title><link>http://jugf.github.io/posts/todesursache-hibernate-31-01-2024/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/todesursache-hibernate-31-01-2024/</guid><description>Hibernate wurde seit Jahren auf die größtenteils automatische Speicherung von Daten und das Laden ganzer Objektgraphen optimiert. Man sollte also annehmen, dass man die meisten Persistenzprobleme alleine durch die Verwendung von Hibernate vermeidet.
Dabei ist es gar nicht so schwer seinem Projekt mit &amp;hellip; oder sollte ich besser sagen &amp;ldquo;Dank Hibernate&amp;rdquo; &amp;hellip; den Todesstoß zu versetzen.
Aus praktischer Erfahrung zeige ich in diesem Vortrag, wie man:
mit nur einer Annotation die halbe Datenbank löschen kann, die Persistenzlogik so implementiert, dass sie garantiert keiner der Kollegen versteht, die Verwendung der Entitäten in Clientanwendungen zuverlässig verhindert und ganz ohne eigenen Code und Annotationen die Datenbank durch tausende Abfragen in die Knie zwingt.</description></item><item><title>22.11.2023: Phantastische Diagramme und wie du sie selbst erstellst</title><link>http://jugf.github.io/posts/phantastische-diagramme-22-11-2023/</link><pubDate>Wed, 02 Aug 2023 06:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/phantastische-diagramme-22-11-2023/</guid><description>Dieser Vortrag findet vor Ort in der Deutschen Nationalbibliothek in Frankfurt statt!
Die wichtigste Aufgabe eines Software-Architekten besteht darin, die Architektur zu kommunizieren.
Neben den textuellen Inhalten gilt es auch, Grafiken zu erstellen. Getreu dem Motto &amp;ldquo;ein Bild sagt mehr als tausend Worte&amp;rdquo; helfen Diagramme bei einer effektiven und pragmatischen Dokumentation. Damit sie wirken, müssen sie leicht erfassbar, stets aktuell und korrekt sein..
In diesem Talk spüren wir zuerst die Schwachstellen vieler Diagramme auf und überlegen uns anschließend, wie wir sie umgehen können.</description></item><item><title>25.10.2023: The Power of Cloud Development Kit (CDK): How to get the most out of it</title><link>http://jugf.github.io/posts/the-power-of-cloud-development-kit-cdk-25-10-2023/</link><pubDate>Wed, 02 Aug 2023 05:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/the-power-of-cloud-development-kit-cdk-25-10-2023/</guid><description>Dieser Vortrag findet vor Ort in der Deutschen Nationalbibliothek in Frankfurt statt!
In den letzten Jahren haben Alex und sein Team in zahlreichen Projekten solide Erfahrungen mit dem Cloud Development Kit (CDK) gesammelt und möchten ihre Erkenntnisse darüber weitergeben, wie man das wahre Potenzial echter Programmiersprachen für Infrastruktur-Entwicklung nutzen kann, auch über die Grenzen von CDK selbst hinweg.
Taucht ein in die Welt von CDK und lernt die Entwicklung von Java-Services auf komplexen AWS- und Kubernetes-Infrastrukturen in einer verteilten Teamumgebung.</description></item><item><title>27.09.2023 Deep Dive into Spring Security 6</title><link>http://jugf.github.io/posts/deep-dive-into-spring-security-6-27-09-2023/</link><pubDate>Mon, 03 Jul 2023 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/deep-dive-into-spring-security-6-27-09-2023/</guid><description>Spring Security gilt als de-facto Lösung für die Sicherung von Spring-basierten Anwendungen.
Anhand von Spring Security lassen sich Anwendungen gegen häufigen Angriffen wie Cross-Site-Request-Forgery (CSRF) mühelos schützen, User Lockouts anhand Events steuern und viel mehr.
Die mehreren Password-Encoder, die Out-of-the-box zur Verfügung stehen, sowie Codebeispiele über Single Sign On, OAuth2 und Multifactor Authentifizierungen (MFA) werden präsentiert, außerdem werdeb Authentifizierungsanbieter wie LDAP berücksichtigt.
Für das Testing werden die im Spring-Security-Test enthaltenen Annotationen und Klassen für Autorisierung benutzt.</description></item><item><title>26.07.2023: Data-Oriented Programming in Java 21</title><link>http://jugf.github.io/posts/data-oriented-programming-in-java-20-26-07-2023/</link><pubDate>Fri, 24 Mar 2023 06:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/data-oriented-programming-in-java-20-26-07-2023/</guid><description>Update: Die Slides zum Vortrag sind hier.
Data-oriented programming models data as data: records for entities and sealed types for alternatives. Combined with pattern matching we can define operations on the data without overloading it with functionality.
In data-oriented programming (DOP), we model data as data and polymorphic behavior with pattern matching. This talk will introduce the concept of DOP and its four principles:
model the data, the whole data, and nothing but the data data is immutable validate at the boundary make illegal states unrepresentable We&amp;rsquo;ll also explore how to use pattern matching as a safe, powerful, and maintainable mechanism for ad-hoc polymorphism on such data that lets us define operations without overloading the types with functionality.</description></item><item><title>28.06.2023: Let’s get started: Der Eclipse Starter für Jakarta EE</title><link>http://jugf.github.io/posts/lets-get-started-der-eclipse-starter-fuer-jakarta-ee-28-06-2023/</link><pubDate>Fri, 24 Mar 2023 05:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/lets-get-started-der-eclipse-starter-fuer-jakarta-ee-28-06-2023/</guid><description>So ziemlich jedes Framework bietet heutzutage eine Starter-Page, auf der man sich ein Demo-Projekt zusammenklicken und herunterladen kann, um das Framework auszuprobieren.
Nur bei Jakarta EE oder vormals Java EE war das bislang nicht der Fall. Ein neues Projekt bekam man in der Regel durch Kopieren eines Vorgängerprojekts oder eines irgendwo veröffentlichten Demoprojekts oder im besten Fall nutzte man irgendeinen veröffentlichten Maven-Archetype als Grundlage. Das ist aber gerade für Neueinsteiger eine große Hürde, was den Einstieg erschwert, zumal der Konkurrent Spring so etwas seit längerem im Angebot hat.</description></item><item><title>31.05.2023: Simulierte Evolution: Hands-On-Starter Kit</title><link>http://jugf.github.io/posts/simulierte-evolution-hands-on-starter-kit-31-05-2023/</link><pubDate>Fri, 24 Mar 2023 04:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/simulierte-evolution-hands-on-starter-kit-31-05-2023/</guid><description>Update 04.06.: Die Vortragsfolien sind hier.
Dieser Vortrag findet vor Ort in der Deutschen Nationalbibliothek in Frankfurt statt!
Evolution ist ein erstaunlich mächtiger und kreativer Prozess. Dieser hat aus Einzellern komplexe und erfolgreiche Lebewesen und uns Menschen hervorgebracht. In biologischen Systemen dauert die Entwicklung zur nächsten Generation oft Monate oder Jahre. Evolutionäre Prozesse finden nicht nur in der Natur, sondern in vielen Umgebungen statt.
Wäre es nicht sinnvoll, dieses mächtige Werkzeug selbst zu nutzen?</description></item><item><title>26.04.2023 Wie wir mit KI die Poststellen unserer Kunden entlasten</title><link>http://jugf.github.io/posts/wie-wir-mit-ki-die-poststellen-unserer-kunden-entlasten-26-04-2023/</link><pubDate>Fri, 24 Mar 2023 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/wie-wir-mit-ki-die-poststellen-unserer-kunden-entlasten-26-04-2023/</guid><description>Update 27.04.: Die Folien sind hier
Mit Hilfe unserer KI-Plattform SHERLOQ entlasten wir die Poststellen unserer Kunden bei Routine-Aufgaben wie Dokumententrennung, Klassifikation und Extraktion — on premise, integriert in die Kunden-IT, mit maßgeschneiderter und -trainierter KI.
In diesem Vortrag:
durchlaufen wir den langen Weg von einer Projekt-Idee bis zum Betrieb in Produktion, beleuchten dabei die typischen Herausforderungen und erklären, mit welchen Techniken und Tools aus den Bereichen KI, ML-Ops und Infrastruktur wir diese meistern.</description></item><item><title>29.03.2023 JUnit 5 wird 5</title><link>http://jugf.github.io/posts/junit5-wird-5/</link><pubDate>Sat, 18 Feb 2023 04:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/junit5-wird-5/</guid><description>Update 29.03.: Folien zum Vortrag, Repo mit Beispielcode
Seit dem ersten Release von JUnit 5 im Jahr 2017 sind mittlerweile fast fünf Jahre vergangen. Das JUnit-Team hat danach jedoch keineswegs die Arbeit eingestellt. Im Gegenteil: Seitdem gab es neun weitere Feature- Releases. In diesem Vortrag werden wir uns nach einer kurzen Einführung in JUnit 5 auf die neuen Features der 5.x Releases konzentrieren.
Diese sind unter anderem:
deklarative Test Suites JFR Events neue Extension Points überarbeiteter Support für temporäre Verzeichnisse Test Method/Class Execution Order ein neues XML Reporting-Format Selbstverständlich wird auch Zeit für Fragen und Feedback eurerseits vorhanden sein.</description></item><item><title>22.02.2023 Tokenisierung von Assets in der Blockchain</title><link>http://jugf.github.io/posts/tokenisierung-von-assets-in-der-blockchain-22-02-2023/</link><pubDate>Thu, 22 Dec 2022 04:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/tokenisierung-von-assets-in-der-blockchain-22-02-2023/</guid><description>Update 22.02.: Die Folien hängen der Seite an.
Die Tokenisierung von Wertgegenständen ist eines der großen Trendthemen im Finanzdienstleistungssektor. Diese Tokenisierung (digitale Replikation von Werten) eröffnet neue Anlagemöglichkeiten. Wir haben zu diesem Zweck Smart Contracts entwickelt und in eine Spring Boot App mit React UI integriert, welche wir technisch sowie fachlich beleuchten wollen.
Andreas Meyer-Berg ist IT-Consultant bei msg und ist Software- sowie Blockchain Entwickler. Als Fullstack Software Engineer entwickelte er von Smart Contracts bis hin zum Frontend große Teile der prototypischen Anwendung.</description></item><item><title>25.01.2023 Project Loom: Revolution in concurrency or obscure implementation detail?</title><link>http://jugf.github.io/posts/project-loom-revolution-in-concurrency-or-obscure-implementation-detail-25-01-2023/</link><pubDate>Thu, 22 Dec 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/project-loom-revolution-in-concurrency-or-obscure-implementation-detail-25-01-2023/</guid><description>Update 25.01.: The slides are here: https://nurkiewicz.com/slides/loom
This talk will be in english.
Project Loom is an effort to bring lightweight threads to the JVM. Such threads have low memory and scheduling footprint so that you can create millions of them. Forget about thread pools. Start creating new threads per each request or connection. Without worrying about memory footprint or context switching. Literally millions of them. Things you can forget about with Loom:</description></item><item><title>07.12.2022 Real-time Fraud Detection: Challenges and Solutions</title><link>http://jugf.github.io/posts/real-time-fraud-detection-challenges-and-solutions-07-12-2022/</link><pubDate>Wed, 23 Nov 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/real-time-fraud-detection-challenges-and-solutions-07-12-2022/</guid><description>This talk will be in english.
Fraud can be considerably reduced via speed, scalability, and stability. Investigating fraudulent activities, using fraud detection machine learning is crucial where decisions need to be made in microseconds, not seconds or even milliseconds.
This becomes more challenging when things get demanding and scaling real-time fraud detection becomes a bottleneck. The talk will address these issues and provide solutions using the Hazelcast Open Source platform.</description></item><item><title>23.11.2022 Reactive Streams in Java</title><link>http://jugf.github.io/posts/reactive-streams-in-java-23-11-2022/</link><pubDate>Thu, 17 Nov 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/reactive-streams-in-java-23-11-2022/</guid><description>Update 23.11.: Die Slides sind hier: 20221123_Reactive_Streams_in_Java.pdf
Heutige Applikationen erfordern oft komplexe Abläufe die aufeinander aufbauen und zeitlich voneinander abhängig sind. Diese zeitlich asynchronen Abläufe entziehen sich unserer Kontrolle, was uns in der Regel vor eine große Herausforderung stellt.
Wie gehen wir also mit Fällen um, die voneinander abhängig sind und zu unbestimmten Zeiten auftreten?
Das Paradigma der &amp;ldquo;reaktiven Programmierung&amp;rdquo; hilft, den Code in mehrere kleine Schritte zu unterteilen, die asynchron ausgeführt werden.</description></item><item><title>28.09.2022 GitHub APIs: Lieferprozesse und Routinetätigkeiten automatisieren</title><link>http://jugf.github.io/posts/github-apis-lieferprozesse-und-routinet%C3%A4tigkeiten-automatisieren-28-09-2022/</link><pubDate>Sun, 04 Sep 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/github-apis-lieferprozesse-und-routinet%C3%A4tigkeiten-automatisieren-28-09-2022/</guid><description>In der Softwareentwicklung gibt es immer wieder Routinetätigkeiten, die automatisiert werden wollen. Befindet sich das Code-Repository auf GitHub, stehen dafür verschiedene APIs zur Verfügung.
Dieser Vortrag zeigt hierfür verschiedene praktische Beispiele: Sei es, um Releases mit GitHub Actions zu automatisieren, Code-Qualität zu prüfen, Repository-Einstellungen als Configuration as Code abzulegen, eigene Custom-Dashboards zu Issues und Pull Requests zu erstellen oder Aktionen über Bots oder REST-APIs zu automatisieren.
In den Vortrag fließen praktischen Erfahrungen aus dem AsciiDoc-IntelliJ-Plug-in und dem Red-Hat-Keycloak-Projekt ein.</description></item><item><title>31.08.2022 GraalVM EE 22.2 Feature Update und Verbesserungen beim Native Image</title><link>http://jugf.github.io/posts/graalvm-22.2-universal-vm-konzepte-und-features-31-08-2022/</link><pubDate>Sun, 31 Jul 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/graalvm-22.2-universal-vm-konzepte-und-features-31-08-2022/</guid><description>Update 04.09.: Die Slides sind hier: 20220831_GraalVM_22
Dies ist einen Präsenzveranstaltung bei Oracle, Details siehe Ablauf
Die GraalVM ist eine universelle Virtuelle Maschine (VM) für Anwendungen, die in JavaScript, Python, Ruby, R oder mit den JVM-basierten Programmiersprachen Java, Scala, Kotlin, Clojure und LLVM-basierten Sprachen C/C++ geschrieben wurden. Im Juli 2022 wurde die GraalVM 22.2 freigegeben, mit Performance-Verbesserungen und polyglotter Unterstützung für verschiedene Programmiersprachen und sie ermöglicht damit die Interoperabilität in einer gemeinsamen Laufzeitumgebung.</description></item><item><title>27.07.2022 Automatisierte Architekturtests und statische Codeanalyse mit ArchUnit</title><link>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-27-07-2022/</link><pubDate>Thu, 14 Jul 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-27-07-2022/</guid><description>Update 30.07.: Die Folien und die Sourcen vom Vortrag
Dies ist eine Präsenzveranstaltung, siehe &amp;ldquo;Ablauf&amp;rdquo;
Im Architektur-Entwurf treffen wir viele Architekturentscheidungen, im besten Fall explizit, dokumentiert und verstanden. Dieser Prozess ist aufwändig und mühsam, mit der Folge, dass viele Entscheidungen meist nur implizit getroffen werden und dann in Vergessenheit geraten.
Eine automatisierte Überprüfung solcher Architekturentscheidungen hilft hier weiter: Manche Entscheidungen wie Namenskonventionen lassen sich schon lange über altbekannte Tools wie Checkstyle leicht abtesten.</description></item><item><title>11.07.2022: Architekturexplizite Java-Applikationen mit jMolecules</title><link>http://jugf.github.io/posts/architekturexplizite-java-applikationen-mit-jmolecules-11-07-2022/</link><pubDate>Wed, 22 Jun 2022 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/architekturexplizite-java-applikationen-mit-jmolecules-11-07-2022/</guid><description>Java-Applikationen basieren üblicherweise auf einem Framework oder einer Entwicklungsplattform. Einige davon erlauben es, architektonische Konzepte auszudrücken. Diese jedoch direkt in Code abzubilden, bleibt meist eine Herausforderung, ebenso wie die Trennung von fachlichem Code und Applikationsframework.
jMolecules ist eine Framework-unabhängige Bibliothek, die es erlaubt, verbreitete, architektonische Konzepte direkt in Code darzustellen, zu überprüfen, ob Regeln bezüglich der Implementierung dieser eingehalten werden und die nötige technische Integration, sowie entsprechende Dokumentation abzuleiten.
Der Vortrag gibt einen Überblick über den grundsätzlichen Ansatz und zeigt, wie Entwickler:innen die bereitgestellten Abstraktionen nutzen können.</description></item><item><title>29.06.2022 VERSCHOBEN: Automatisierte Architekturtests und statische Codeanalyse mit ArchUnit</title><link>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-29-06-2022.md/</link><pubDate>Sun, 22 May 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-29-06-2022.md/</guid><description>Update 28.06.: Die Veranstaltung muss krankheitsbedingt leider entfallen!
Im Architektur-Entwurf treffen wir viele Architekturentscheidungen, im besten Fall explizit, dokumentiert und verstanden. Dieser Prozess ist aufwändig und mühsam, mit der Folge, dass viele Entscheidungen meist nur implizit getroffen werden und dann in Vergessenheit geraten.
Eine automatisierte Überprüfung solcher Architekturentscheidungen hilft hier weiter: Manche Entscheidungen wie Namenskonventionen lassen sich schon lange über altbekannte Tools wie Checkstyle leicht abtesten. Komplexere Entscheidungen aber lassen sich nicht immer einfach checken - oder sie erfordern ein komplexes Metamodell, das aufwändig zu erstellen und zu pflegen ist.</description></item><item><title>25.05.2022: DDD und hexagonale Architektur in der Bank</title><link>http://jugf.github.io/posts/ddd-und-hexagonale-architektur-in-der-bank-25-05-2022/</link><pubDate>Sat, 19 Feb 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/ddd-und-hexagonale-architektur-in-der-bank-25-05-2022/</guid><description>Update 01.06.2022: Die Folien von Konnis Vortrag sind der Seite angehängt: DDD_hexagonale_Architektur_Andreas_Konrad.pdf
Wenn man auf Konferenzen unterwegs ist, bekommt man schnell den Eindruck, Domain Driven Design sei ein alter Hut. Ich bin überzeugt, dass das für viele Entwickler noch nicht der Fall ist. Speziell in einigen Branchen wird eher auf Stabilität und Bekanntes gesetzt, als neue Technologien und Methoden. Das erlebe ich persönlich in meinem Beruf und im Austausch mit Kollegen aus anderen Firmen.</description></item><item><title>27.04.2022: Domain-driven Design für Dummies</title><link>http://jugf.github.io/posts/domain-driven-design-fuer-dummies-27-04-2022/</link><pubDate>Wed, 29 Dec 2021 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/domain-driven-design-fuer-dummies-27-04-2022/</guid><description>Auch wenn das gleichnamige Buch von Eric Evans bereits 2003 erschienen ist, so ist Domain Driven Design gerade wieder hoch aktuell und nicht zuletzt durch den Trend zu Microservices Architekturen immer noch sehr relevant. Ziel von DDD ist die möglichst realitätsnahe Abbildung der Fachlichkeit und des Domainwissens in der Software. Das Entwickeln einer gemeinsamen domänengetriebenen Fachsprache hilft bei der Überbrückung von Kommunikationsproblemen zwischen den Fachanwendern und den Softwareentwicklern.
In diesem Vortrag wollen wir einen Blick auf die Konzepte und Muster wie Context Mapping, Bounded Contexts, Domain Events und die internen Building Blocks wie Aggregate, Entities, Value Objects, Repositories usw.</description></item><item><title>30.03.2022: Easy-Rider: Unit-Tests für datengetriebene Komponenten mit DB-Rider</title><link>http://jugf.github.io/posts/easy-rider-unit-tests-fuer-datengetriebene-komponenten-30-03-2022/</link><pubDate>Wed, 29 Dec 2021 02:59:00 +0100</pubDate><guid>http://jugf.github.io/posts/easy-rider-unit-tests-fuer-datengetriebene-komponenten-30-03-2022/</guid><description>Software altert nicht durch Abnutzung wie Werkzeuge oder Gebäude, sondern durch Erweiterungen und das Einfügen von Änderungen. Die beste Absicherung ist ein weitsichtiges Design und eine breite Abdeckung mit Tests, die einzelne Funktionen in Isolation automatisch prüfen. Leider ist es immer noch nicht für alle Teile einer Applikation leicht gute Tests zu erstellen. Das galt lange Zeit für die Datenzugriffsschicht, die eng mit einer Datenbank interagiert.
Zum Glück gibt es Frameworks, die uns helfen auch diese Teile einer Applikation zu verifizieren, wie zum Beispiel DB-Rider (https://github.</description></item><item><title>23.02.2022: Infrastructure as Code – Korrektheit beweisen statt testen</title><link>http://jugf.github.io/posts/infrastructure-as-code-korrektheit-beweisen-statt-testen-23-02-2022/</link><pubDate>Wed, 29 Dec 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/infrastructure-as-code-korrektheit-beweisen-statt-testen-23-02-2022/</guid><description>Du baust deine Infrastruktur als Code (IaC), z.B. mit Ansible, Terraform oder Kubernetes Manifests und Helm Charts? Wie kannst du sicher sein, dass alles korrekt ist, ohne es in eine reale Umgebung zu deployen?
jQAssistant (jQA) kann dir dabei helfen! Damit kannst du deine IaC-Definitionen scannen und analysieren, bevor du sie ausrollst. Durch Integration in dein Build-System wird jede Änderung semantisch geprüft und zurückgewiesen, wenn von dir definierte Constraints nicht erfüllt sind – die Feedback-Loop verkürzt sich erheblich.</description></item><item><title>26.01.2022: Hands-on mit Quarkus</title><link>http://jugf.github.io/posts/hands-on-mit-quarkus-26-01-2022/</link><pubDate>Mon, 20 Dec 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/hands-on-mit-quarkus-26-01-2022/</guid><description>Bitte beachten: Der Vortrag beginnt um 19 Uhr, nicht 18:30.
Quarkus erfreut sich wachsender Popularität und ist auf dem besten Weg, eine ernstzunehmende Alternative zu Spring Boot zu werden. Insbesondere Teams, die bislang auf Basis von Java EE bzw. Jakarta EE entwickelt haben, werden von Quarkus abgeholt. Das Framework ermöglicht diesen Teams, ihr vorhandenes Know-how zu großen Teilen weiter zu nutzen, aber gleichzeitig Anwendungen auf modernstem technischen Fundament zu entwickeln. JAX-RS, CDI und JPA werden ebenso unterstützt wie MicroProfile, Kafka, Docker, Kubernetes oder die Erstellung nativer Images mit der GraalVM.</description></item><item><title>22.12.2021: Kubernetes Murder Mystery</title><link>http://jugf.github.io/posts/kubernetes-murder-mystery-22-12-2021/</link><pubDate>Sat, 27 Nov 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/kubernetes-murder-mystery-22-12-2021/</guid><description>Die Cloud ist eine Ansammlung von Computern anderer Leute, und Kubernetes ist eine populäre Lösung, Anwendungen auf einer Gruppe von Rechnern laufen zu lassen. Eine erste &amp;ldquo;Hello World&amp;rdquo;-Anwendung mit einem Kubernetes-Pod läuft bald, doch dann: Kubernetes bringt den ersten Pod &amp;ldquo;um die Ecke&amp;rdquo;! Warum startet der Pod nicht, warum wird er einfach so beendet, und wie kann ich das verhindern?
In diesem interaktiven Vortrag gehen wir gemeinsam verschiedenen Phänomenen auf den Grund und schauen dabei hinter die Kulissen von Kubernetes.</description></item><item><title>24.11.2021: Property-based Testing mit Java</title><link>http://jugf.github.io/posts/property-based-testing-java-24-11-2021/</link><pubDate>Mon, 18 Oct 2021 10:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/property-based-testing-java-24-11-2021/</guid><description>Update 25.11.2021: Link zu den Folien: https://johanneslink.net/downloads/PropertyTesting-JUGF.pdf und zum Blogpost: https://johanneslink.net/model-based-testing/
Testgetriebene Entwicklung in Java und anderen objektorientierten Sprachen setzt bislang meist auf beispielbasierte Testfälle, wie man sie leicht mit JUnit und ähnlichen Testframeworks erstellen kann. Schaut man jedoch über den Tellerrand und auf funktionale Programmiersprachen wie z.B. Haskell oder F#, findet man dort etwas anderes: Property-basiertes Testen (engl. Property-based Testing).
Property-based Testing basieren auf der Idee, die erwünschten Eigenschaften unseres Programms zu beschreiben und anschließend das Framework selbstständig Testfälle generieren zu lassen, die diese Eigenschaften bestätigen oder falsifizieren.</description></item><item><title>27.10.2021: Extending Exasol with Java</title><link>http://jugf.github.io/posts/extending-exasol-with-java-27-10-2021/</link><pubDate>Sun, 08 Aug 2021 08:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/extending-exasol-with-java-27-10-2021/</guid><description>Update 28.10.2021: Die Folien zum Vortrag sind hier (Github-Repos sind dort enthalten)
Exasol ist eine verteilte analytische In-memory-Datenbank. Kunden und Partner verwenden Schnittstellen in vielen Programmiersprachen, um Exasol zu erweitern. Java ist die im Enterprise-Bereich beliebteste Schnittstelle.
In dieser Demonstration zeigen wir, wie man Exasol mit Java um eine nutzerdefinierte Funktion erweitert und Beispiele dafür, was man damit alles machen kann. Außerdem stellen wir Exasol Testcontainers vor, eine bequeme Art, Exasol in Integrationstests zu verwenden.</description></item><item><title>29.09.2021: Den eigenen Code sprechen lassen mit Java Text-to-Speech</title><link>http://jugf.github.io/posts/den-eigenen-code-sprechen-lassen-mit-java-text-to-speech-29-09-2021/</link><pubDate>Wed, 12 May 2021 14:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/den-eigenen-code-sprechen-lassen-mit-java-text-to-speech-29-09-2021/</guid><description>Ob Vorlesefunktion oder komplexe Ansagen in einer Hotline, Text-to-Speech ist heutzutage allgegenwärtig. Doch wie genau funktioniert dies eigentlich und wie könnten eigene Programme mit solch einer Funktionalität ausgestattet werden? In diesem Vortrag zeigt Pascal mit Mary Text-To-Speech dies näher auf.
Mary ist eine in Java geschriebene Open Source Plattform. Die Sprachausgabe lässt sich für verschiedene Stimmen und Sprachen anwenden.
Neben Programmcode stellt Pascal außerdem noch eines seiner Open Source Projekte vor, bei dem Mary mit mehreren Stimmen zum Einsatz kommt.</description></item><item><title>25.08.2021: MicroStream: High-Performance Java Persistence in Real-World Anwendungen</title><link>http://jugf.github.io/posts/microstream-high-performance-java-persistence-in-real-world-anwendungen-25-08-2021/</link><pubDate>Tue, 27 Apr 2021 10:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/microstream-high-performance-java-persistence-in-real-world-anwendungen-25-08-2021/</guid><description>MicroStream ist ein fundamental neues Persistenz-Framework für die native Speicherung komplexer Java Objektgraphen. Java Objekte werden damit genau so persistent gespeichert, wie diese im Hauptspeicher von der JVM verwaltet werden. Umgekehrt lassen sich zu jeder Zeit einzelne Subgraphen in den RAM laden und der Objektgraph im Hauptspeicher wird automatisch aktualisiert. Dadurch ergeben sich völlig neue Möglichkeiten: Objektgraphen lassen sich als In-Memory Datenbank verwenden. Ein Objektgraph ist dabei eine sehr mächtige Multi-Model Datenstruktur.</description></item><item><title>28.07.2021: API-first Ansatz: Moderne Architekturen für Open Banking APIs</title><link>http://jugf.github.io/posts/api-first-ansatz-moderne-architekturen-fuer-open-banking-apis-28-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/api-first-ansatz-moderne-architekturen-fuer-open-banking-apis-28-06-2021/</guid><description>Aufgrund regulatorischer Anforderungen sind Finanzinstitute seit 2019 verpflichtet Services über APIs für Drittanbieter bereitzustellen. Die Einführung dieser APIs stellt die Finanzinstitute bis heute vor große Herausforderungen und führt zu einem Wandel in den Geschäftsmodellen der Banken.
Mit einem API-first Ansatz können die Finanzinstitute ihre IT-Landschaft an diese neuen Herausforderungen anpassen, Datensilos öffnen und ihr digitales Eco-System erweitern. So sind sie in der Lage nicht nur die regulatorischen Anforderungen zu erfüllen sondern auch auf Basis moderner Architekturen leichter und schneller interne und externe Services bereitzustellen.</description></item><item><title>30.06.2021: Die GraalVM ist ein polyglotter native Speaker</title><link>http://jugf.github.io/posts/die-graalvm-ist-ein-polyglotter-native-speaker-30-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/die-graalvm-ist-ein-polyglotter-native-speaker-30-06-2021/</guid><description>Update 06.07.: Die Folien sind hier: https://speakerdeck.com/mrtnlhmnn/die-graalvm-ist-ein-polyglotter-native-speaker Zusätzlich gibt es noch die Repos mit den Beispielen: https://github.com/accso/graalvm-polyglot und https://github.com/accso/graalvm-native
Die GraalVM ist eine - gar nicht mal so neue - Java VM, die Schritt für Schritt immer mehr Produktionsreife und Popularität bei Entwicklern und Architekten gewinnt. Graal macht vor allem zwei Aspekte anders als die altbekannte HotspotVM:
Die Zukunft der JVM ist polyglott! Das wurde bereits mit Java 7 verkündet. Mit der GraalVM gewinnt viele Jahre später eine neue Java VM an Popularität, die sich ebenfalls das Thema polyglotte Programmierung auf die Fahne geschrieben hat.</description></item><item><title>16.06.2021: Why Don't They Just...?! The Deliberations Behind Evolving Java</title><link>http://jugf.github.io/posts/why-dont-they-just-evolving-java-16-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:56 +0100</pubDate><guid>http://jugf.github.io/posts/why-dont-they-just-evolving-java-16-06-2021/</guid><description>Update 18.06.
Die Slides zum Vortrag sind hier: https://slides.nipafx.dev/just/2021-06-16-jug-ffm Rabattcode (20%) zu Accento am 28./29.09. in Karlsruhe https://accento.dev: AccJUGFFM21 There are many nifty features that Java could have but doesn&amp;rsquo;t. Somewhat surprisingly, there are reasons for that and in this talk I&amp;rsquo;ll discuss those for a few concrete cases as well as the deliberations behind such decisions.
There are many nifty features that Java could have but doesn&amp;rsquo;t. Why, though, how hard can it be to implement them?</description></item><item><title>26.05.2021: GraalVM 21 Feature Update der universellen VM</title><link>http://jugf.github.io/posts/graalvm-21-feature-update-der-universellen-vm-26-05-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:55 +0100</pubDate><guid>http://jugf.github.io/posts/graalvm-21-feature-update-der-universellen-vm-26-05-2021/</guid><description>Update 28.05.: Die Folien zum Vortrag sind hier: 20210526_Weigend_GraalVM_21
Die GraalVM ist eine universelle Virtuelle Maschine (VM) für Anwendungen, die in JavaScript, Python, Ruby, R oder mit den JVM-basierten Programmiersprachen Java, Scala, Kotlin, Clojure und LLVM-basierten Sprachen C/C++ geschrieben wurden. Im April 2021 wurde die GraalVM 21.1.0 freigegeben, mit Performance-Verbesserungen und polyglotter Unterstützung für verschiedene Programmiersprachen und sie ermöglicht damit die Interoperabilität in einer gemeinsamen Laufzeitumgebung. GraalVM kann eigenständig oder im Kontext von OpenJDK, Node.</description></item><item><title>29.04.2021: Wie gut kennst Du das Collections Framework?</title><link>http://jugf.github.io/posts/wie-gut-kennst-du-das-collections-framework-29-04-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:52 +0100</pubDate><guid>http://jugf.github.io/posts/wie-gut-kennst-du-das-collections-framework-29-04-2021/</guid><description>Update 03.05.: Die Folien zum Vortrag sind hier: 20210429_Frotscher-Collections-Framework.pdf
HashMap und ArrayList kennt jeder, na klar. Aber wann stellen sie eigentlich die richtige Wahl dar? Und vor allem: Wann nicht? Das Collections Framework enthält zahlreiche, zum Teil recht spezialisierte Implementierungen, doch viele Entwickler kennen nur einen kleinen Teil davon. Schon mal was von EnumSet oder WeakHashMap gehört? Und was ist eigentlich der Unterschied zwischen ConcurrentSkipListMap und ConcurrentHashMap? Je nachdem, welche konkreten Anforderungen jeweils umzusetzen sind, ist es wichtig, die Stärken und Schwächen der einzelnen Implementierungen zu kennen.</description></item><item><title>31.03.2021: Resilient Software Design Patterns</title><link>http://jugf.github.io/posts/resilient-software-design-patterns-31-03-2021/</link><pubDate>Mon, 11 Jan 2021 10:39:03 +0100</pubDate><guid>http://jugf.github.io/posts/resilient-software-design-patterns-31-03-2021/</guid><description>Update 01.04.: Die Folien zum Vortrag sind hier: Resilience_Patterns_JUGF_2021.pdf
Die Zeiten in denen eine Anwendung aus einem einzelnen großen Artefakt besteht, scheinen vorbei zu sein. Unter anderem im Zuge der verstärkten Containerisierung mit Docker &amp;amp; Co wird es immer beliebter, Anwendungen aus mehreren möglichst unabhängigen Artefakten zusammenzustellen, die über Prozessgrenzen miteinander kommunizieren. Diese Architektur ermöglicht eine schnellere Weiterentwicklung und eine elastische Anpassung an wechselnde Lastanforderungen. Falls nun eine Vielzahl an kleineren Anwendungen eine gemeinsame Aufgabe erfüllen sollen, wird ein fehlerfreies Gesamtsystem allerdings zunehmend unwahrscheinlicher.</description></item><item><title>24.02.2021: Blockchain Indizierung mit Apache Storm</title><link>http://jugf.github.io/posts/blockchain-indizierung-mit-apache-storm-24-02-2021/</link><pubDate>Sun, 10 Jan 2021 15:34:33 +0100</pubDate><guid>http://jugf.github.io/posts/blockchain-indizierung-mit-apache-storm-24-02-2021/</guid><description>Update 27.02.: Die Folien zum Vortrag sind hier: 20210224_blockchain_storm.pdf, das Github Repo zu den Sourcen ist https://github.com/jondoe1337/storm-example
Dezentrale Blockchains - Zentral indizieren? Zwei konträre Konzepte miteinander zu vereinen gab es sicher schon oft, dennoch besteht bei diesen beiden Konzepten noch das Problem der Datenmenge und Echtzeitanforderungen im Raum. Mit Apache Storm wurde eine flexible und schnelle Abarbeitung der Informationen die aktuelle Blockchains emittieren ermöglicht und schafft es als Bindeglied verschiedene Technologien einfach zu verbinden.</description></item><item><title>27.01.2021: Das Java Quiz - Was ihr schon immer über Java wußtet, aber euch niemand fragen wollte.</title><link>http://jugf.github.io/posts/das-java-quiz-27-01-2021/</link><pubDate>Tue, 22 Dec 2020 21:10:48 +0100</pubDate><guid>http://jugf.github.io/posts/das-java-quiz-27-01-2021/</guid><description>Update 28.01.: Die Folien zum Quiz sind hier: 20210127_JUGF_Java11_Quiz.pdf
Wie gut kennt ihr euch wirklich in der Java-Welt aus? Mit einer Auswahl von Fragen aus verschiedensten Quellen quer durch das Java-Beet wollen wir das herausfinden. Die Fragen entbehren nicht einer gewissen Knifflizität, könnten einem aber trotzdem im Entwickleralltag über den Weg laufen. Um der Lebensrealität der Mehrheit der Java-Entwickler gerecht zu werden, ist Java 11 die Basis für das Quiz.</description></item><item><title>JUGFs New Home</title><link>http://jugf.github.io/posts/jugfs-new-home/</link><pubDate>Tue, 22 Dec 2020 13:39:39 +0100</pubDate><guid>http://jugf.github.io/posts/jugfs-new-home/</guid><description>Bye Bye Google Sites Leider wird Google Sites, mit dem auch die bestehende jugf.de-Seite erstellt wurde, neu aufgesetzt, mobile-first, responsive usw. usf. Das ist sicherlich sinnvoll, leider werden &amp;ldquo;Bestandskunden&amp;rdquo; bei der Migration nicht wirklich unterstützt. Die automatische Migration auf das neue Format macht das Layout (noch) unbenutzbar(er).
Wir wollen uns nicht beschweren, das damalige Aufsetzen war sehr einfach und der Betrieb war die ganze Zeit über - also nun mehr als 10 Jahre - kostenlos und unproblematisch.</description></item></channel></rss>