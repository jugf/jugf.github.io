<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JUG Frankfurt on Main</title><link>http://jugf.github.io/</link><description>Recent content in JUG Frankfurt on Main</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Java User Group Frankfurt</copyright><lastBuildDate>Sun, 31 Jul 2022 03:00:00 +0100</lastBuildDate><atom:link href="http://jugf.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>31.08.2022 GraalVM EE 22.2 Feature Update und Verbesserungen beim Native Image</title><link>http://jugf.github.io/posts/graalvm-22.2-universal-vm-konzepte-und-features-31-08-2022/</link><pubDate>Sun, 31 Jul 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/graalvm-22.2-universal-vm-konzepte-und-features-31-08-2022/</guid><description>Die ist einen Präsenzveranstaltung bei Oracle, Details siehe Ablauf
Die GraalVM ist eine universelle Virtuelle Maschine (VM) für Anwendungen, die in JavaScript, Python, Ruby, R oder mit den JVM-basierten Programmiersprachen Java, Scala, Kotlin, Clojure und LLVM-basierten Sprachen C/C++ geschrieben wurden. Im Juli 2022 wurde die GraalVM 22.2 freigegeben, mit Performance-Verbesserungen und polyglotter Unterstützung für verschiedene Programmiersprachen und sie ermöglicht damit die Interoperabilität in einer gemeinsamen Laufzeitumgebung.
Die GraalVM JDK-Basisdistribution mit ihrer Größe der Laufzeitumgebung wurde verkleinert und damit die Download-Zeiten verringert.</description></item><item><title>27.07.2022 Automatisierte Architekturtests und statische Codeanalyse mit ArchUnit</title><link>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-27-07-2022/</link><pubDate>Thu, 14 Jul 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-27-07-2022/</guid><description>Update 30.07.: Die Folien und die Sourcen vom Vortrag
Dies ist eine Präsenzveranstaltung, siehe &amp;ldquo;Ablauf&amp;rdquo;
Im Architektur-Entwurf treffen wir viele Architekturentscheidungen, im besten Fall explizit, dokumentiert und verstanden. Dieser Prozess ist aufwändig und mühsam, mit der Folge, dass viele Entscheidungen meist nur implizit getroffen werden und dann in Vergessenheit geraten.
Eine automatisierte Überprüfung solcher Architekturentscheidungen hilft hier weiter: Manche Entscheidungen wie Namenskonventionen lassen sich schon lange über altbekannte Tools wie Checkstyle leicht abtesten.</description></item><item><title>11.07.2022: Architekturexplizite Java-Applikationen mit jMolecules</title><link>http://jugf.github.io/posts/architekturexplizite-java-applikationen-mit-jmolecules-11-07-2022/</link><pubDate>Wed, 22 Jun 2022 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/architekturexplizite-java-applikationen-mit-jmolecules-11-07-2022/</guid><description>Java-Applikationen basieren üblicherweise auf einem Framework oder einer Entwicklungsplattform. Einige davon erlauben es, architektonische Konzepte auszudrücken. Diese jedoch direkt in Code abzubilden, bleibt meist eine Herausforderung, ebenso wie die Trennung von fachlichem Code und Applikationsframework.
jMolecules ist eine Framework-unabhängige Bibliothek, die es erlaubt, verbreitete, architektonische Konzepte direkt in Code darzustellen, zu überprüfen, ob Regeln bezüglich der Implementierung dieser eingehalten werden und die nötige technische Integration, sowie entsprechende Dokumentation abzuleiten.
Der Vortrag gibt einen Überblick über den grundsätzlichen Ansatz und zeigt, wie Entwickler:innen die bereitgestellten Abstraktionen nutzen können.</description></item><item><title>29.06.2022 VERSCHOBEN: Automatisierte Architekturtests und statische Codeanalyse mit ArchUnit</title><link>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-29-06-2022.md/</link><pubDate>Sun, 22 May 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/automatisierte-architekturtests-statische-codeanalyse-archunit-29-06-2022.md/</guid><description>Update 28.06.: Die Veranstaltung muss krankheitsbedingt leider entfallen!
Im Architektur-Entwurf treffen wir viele Architekturentscheidungen, im besten Fall explizit, dokumentiert und verstanden. Dieser Prozess ist aufwändig und mühsam, mit der Folge, dass viele Entscheidungen meist nur implizit getroffen werden und dann in Vergessenheit geraten.
Eine automatisierte Überprüfung solcher Architekturentscheidungen hilft hier weiter: Manche Entscheidungen wie Namenskonventionen lassen sich schon lange über altbekannte Tools wie Checkstyle leicht abtesten. Komplexere Entscheidungen aber lassen sich nicht immer einfach checken - oder sie erfordern ein komplexes Metamodell, das aufwändig zu erstellen und zu pflegen ist.</description></item><item><title>25.05.2022: DDD und hexagonale Architektur in der Bank</title><link>http://jugf.github.io/posts/ddd-und-hexagonale-architektur-in-der-bank-25-05-2022/</link><pubDate>Sat, 19 Feb 2022 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/ddd-und-hexagonale-architektur-in-der-bank-25-05-2022/</guid><description>Update 01.06.2022: Die Folien von Konnis Vortrag sind der Seite angehängt: DDD_hexagonale_Architektur_Andreas_Konrad.pdf
Wenn man auf Konferenzen unterwegs ist, bekommt man schnell den Eindruck, Domain Driven Design sei ein alter Hut. Ich bin überzeugt, dass das für viele Entwickler noch nicht der Fall ist. Speziell in einigen Branchen wird eher auf Stabilität und Bekanntes gesetzt, als neue Technologien und Methoden. Das erlebe ich persönlich in meinem Beruf und im Austausch mit Kollegen aus anderen Firmen.</description></item><item><title>27.04.2022: Domain-driven Design für Dummies</title><link>http://jugf.github.io/posts/domain-driven-design-fuer-dummies-27-04-2022/</link><pubDate>Wed, 29 Dec 2021 03:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/domain-driven-design-fuer-dummies-27-04-2022/</guid><description>Auch wenn das gleichnamige Buch von Eric Evans bereits 2003 erschienen ist, so ist Domain Driven Design gerade wieder hoch aktuell und nicht zuletzt durch den Trend zu Microservices Architekturen immer noch sehr relevant. Ziel von DDD ist die möglichst realitätsnahe Abbildung der Fachlichkeit und des Domainwissens in der Software. Das Entwickeln einer gemeinsamen domänengetriebenen Fachsprache hilft bei der Überbrückung von Kommunikationsproblemen zwischen den Fachanwendern und den Softwareentwicklern.
In diesem Vortrag wollen wir einen Blick auf die Konzepte und Muster wie Context Mapping, Bounded Contexts, Domain Events und die internen Building Blocks wie Aggregate, Entities, Value Objects, Repositories usw.</description></item><item><title>30.03.2022: Easy-Rider: Unit-Tests für datengetriebene Komponenten mit DB-Rider</title><link>http://jugf.github.io/posts/easy-rider-unit-tests-fuer-datengetriebene-komponenten-30-03-2022/</link><pubDate>Wed, 29 Dec 2021 02:59:00 +0100</pubDate><guid>http://jugf.github.io/posts/easy-rider-unit-tests-fuer-datengetriebene-komponenten-30-03-2022/</guid><description>Software altert nicht durch Abnutzung wie Werkzeuge oder Gebäude, sondern durch Erweiterungen und das Einfügen von Änderungen. Die beste Absicherung ist ein weitsichtiges Design und eine breite Abdeckung mit Tests, die einzelne Funktionen in Isolation automatisch prüfen. Leider ist es immer noch nicht für alle Teile einer Applikation leicht gute Tests zu erstellen. Das galt lange Zeit für die Datenzugriffsschicht, die eng mit einer Datenbank interagiert.
Zum Glück gibt es Frameworks, die uns helfen auch diese Teile einer Applikation zu verifizieren, wie zum Beispiel DB-Rider (https://github.</description></item><item><title>23.02.2022: Infrastructure as Code – Korrektheit beweisen statt testen</title><link>http://jugf.github.io/posts/infrastructure-as-code-korrektheit-beweisen-statt-testen-23-02-2022/</link><pubDate>Wed, 29 Dec 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/infrastructure-as-code-korrektheit-beweisen-statt-testen-23-02-2022/</guid><description>Du baust deine Infrastruktur als Code (IaC), z.B. mit Ansible, Terraform oder Kubernetes Manifests und Helm Charts? Wie kannst du sicher sein, dass alles korrekt ist, ohne es in eine reale Umgebung zu deployen?
jQAssistant (jQA) kann dir dabei helfen! Damit kannst du deine IaC-Definitionen scannen und analysieren, bevor du sie ausrollst. Durch Integration in dein Build-System wird jede Änderung semantisch geprüft und zurückgewiesen, wenn von dir definierte Constraints nicht erfüllt sind – die Feedback-Loop verkürzt sich erheblich.</description></item><item><title>26.01.2022: Hands-on mit Quarkus</title><link>http://jugf.github.io/posts/hands-on-mit-quarkus-26-01-2022/</link><pubDate>Mon, 20 Dec 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/hands-on-mit-quarkus-26-01-2022/</guid><description>Bitte beachten: Der Vortrag beginnt um 19 Uhr, nicht 18:30.
Quarkus erfreut sich wachsender Popularität und ist auf dem besten Weg, eine ernstzunehmende Alternative zu Spring Boot zu werden. Insbesondere Teams, die bislang auf Basis von Java EE bzw. Jakarta EE entwickelt haben, werden von Quarkus abgeholt. Das Framework ermöglicht diesen Teams, ihr vorhandenes Know-how zu großen Teilen weiter zu nutzen, aber gleichzeitig Anwendungen auf modernstem technischen Fundament zu entwickeln. JAX-RS, CDI und JPA werden ebenso unterstützt wie MicroProfile, Kafka, Docker, Kubernetes oder die Erstellung nativer Images mit der GraalVM.</description></item><item><title>22.12.2021: Kubernetes Murder Mystery</title><link>http://jugf.github.io/posts/kubernetes-murder-mystery-22-12-2021/</link><pubDate>Sat, 27 Nov 2021 01:00:00 +0100</pubDate><guid>http://jugf.github.io/posts/kubernetes-murder-mystery-22-12-2021/</guid><description>Die Cloud ist eine Ansammlung von Computern anderer Leute, und Kubernetes ist eine populäre Lösung, Anwendungen auf einer Gruppe von Rechnern laufen zu lassen. Eine erste &amp;ldquo;Hello World&amp;rdquo;-Anwendung mit einem Kubernetes-Pod läuft bald, doch dann: Kubernetes bringt den ersten Pod &amp;ldquo;um die Ecke&amp;rdquo;! Warum startet der Pod nicht, warum wird er einfach so beendet, und wie kann ich das verhindern?
In diesem interaktiven Vortrag gehen wir gemeinsam verschiedenen Phänomenen auf den Grund und schauen dabei hinter die Kulissen von Kubernetes.</description></item><item><title>24.11.2021: Property-based Testing mit Java</title><link>http://jugf.github.io/posts/property-based-testing-java-24-11-2021/</link><pubDate>Mon, 18 Oct 2021 10:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/property-based-testing-java-24-11-2021/</guid><description>Update 25.11.2021: Link zu den Folien: https://johanneslink.net/downloads/PropertyTesting-JUGF.pdf und zum Blogpost: https://johanneslink.net/model-based-testing/
Testgetriebene Entwicklung in Java und anderen objektorientierten Sprachen setzt bislang meist auf beispielbasierte Testfälle, wie man sie leicht mit JUnit und ähnlichen Testframeworks erstellen kann. Schaut man jedoch über den Tellerrand und auf funktionale Programmiersprachen wie z.B. Haskell oder F#, findet man dort etwas anderes: Property-basiertes Testen (engl. Property-based Testing).
Property-based Testing basieren auf der Idee, die erwünschten Eigenschaften unseres Programms zu beschreiben und anschließend das Framework selbstständig Testfälle generieren zu lassen, die diese Eigenschaften bestätigen oder falsifizieren.</description></item><item><title>27.10.2021: Extending Exasol with Java</title><link>http://jugf.github.io/posts/extending-exasol-with-java-27-10-2021/</link><pubDate>Sun, 08 Aug 2021 08:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/extending-exasol-with-java-27-10-2021/</guid><description>Update 28.10.2021: Die Folien zum Vortrag sind hier (Github-Repos sind dort enthalten)
Exasol ist eine verteilte analytische In-memory-Datenbank. Kunden und Partner verwenden Schnittstellen in vielen Programmiersprachen, um Exasol zu erweitern. Java ist die im Enterprise-Bereich beliebteste Schnittstelle.
In dieser Demonstration zeigen wir, wie man Exasol mit Java um eine nutzerdefinierte Funktion erweitert und Beispiele dafür, was man damit alles machen kann. Außerdem stellen wir Exasol Testcontainers vor, eine bequeme Art, Exasol in Integrationstests zu verwenden.</description></item><item><title>29.09.2021: Den eigenen Code sprechen lassen mit Java Text-to-Speech</title><link>http://jugf.github.io/posts/den-eigenen-code-sprechen-lassen-mit-java-text-to-speech-29-09-2021/</link><pubDate>Wed, 12 May 2021 14:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/den-eigenen-code-sprechen-lassen-mit-java-text-to-speech-29-09-2021/</guid><description>Ob Vorlesefunktion oder komplexe Ansagen in einer Hotline, Text-to-Speech ist heutzutage allgegenwärtig. Doch wie genau funktioniert dies eigentlich und wie könnten eigene Programme mit solch einer Funktionalität ausgestattet werden? In diesem Vortrag zeigt Pascal mit Mary Text-To-Speech dies näher auf.
Mary ist eine in Java geschriebene Open Source Plattform. Die Sprachausgabe lässt sich für verschiedene Stimmen und Sprachen anwenden.
Neben Programmcode stellt Pascal außerdem noch eines seiner Open Source Projekte vor, bei dem Mary mit mehreren Stimmen zum Einsatz kommt.</description></item><item><title>25.08.2021: MicroStream: High-Performance Java Persistence in Real-World Anwendungen</title><link>http://jugf.github.io/posts/microstream-high-performance-java-persistence-in-real-world-anwendungen-25-08-2021/</link><pubDate>Tue, 27 Apr 2021 10:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/microstream-high-performance-java-persistence-in-real-world-anwendungen-25-08-2021/</guid><description>MicroStream ist ein fundamental neues Persistenz-Framework für die native Speicherung komplexer Java Objektgraphen. Java Objekte werden damit genau so persistent gespeichert, wie diese im Hauptspeicher von der JVM verwaltet werden. Umgekehrt lassen sich zu jeder Zeit einzelne Subgraphen in den RAM laden und der Objektgraph im Hauptspeicher wird automatisch aktualisiert. Dadurch ergeben sich völlig neue Möglichkeiten: Objektgraphen lassen sich als In-Memory Datenbank verwenden. Ein Objektgraph ist dabei eine sehr mächtige Multi-Model Datenstruktur.</description></item><item><title>28.07.2021: API-first Ansatz: Moderne Architekturen für Open Banking APIs</title><link>http://jugf.github.io/posts/api-first-ansatz-moderne-architekturen-fuer-open-banking-apis-28-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:41:54 +0100</pubDate><guid>http://jugf.github.io/posts/api-first-ansatz-moderne-architekturen-fuer-open-banking-apis-28-06-2021/</guid><description>Aufgrund regulatorischer Anforderungen sind Finanzinstitute seit 2019 verpflichtet Services über APIs für Drittanbieter bereitzustellen. Die Einführung dieser APIs stellt die Finanzinstitute bis heute vor große Herausforderungen und führt zu einem Wandel in den Geschäftsmodellen der Banken.
Mit einem API-first Ansatz können die Finanzinstitute ihre IT-Landschaft an diese neuen Herausforderungen anpassen, Datensilos öffnen und ihr digitales Eco-System erweitern. So sind sie in der Lage nicht nur die regulatorischen Anforderungen zu erfüllen sondern auch auf Basis moderner Architekturen leichter und schneller interne und externe Services bereitzustellen.</description></item><item><title>30.06.2021: Die GraalVM ist ein polyglotter native Speaker</title><link>http://jugf.github.io/posts/die-graalvm-ist-ein-polyglotter-native-speaker-30-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:41:52 +0100</pubDate><guid>http://jugf.github.io/posts/die-graalvm-ist-ein-polyglotter-native-speaker-30-06-2021/</guid><description>Update 06.07.: Die Folien sind hier: https://speakerdeck.com/mrtnlhmnn/die-graalvm-ist-ein-polyglotter-native-speaker Zusätzlich gibt es noch die Repos mit den Beispielen: https://github.com/accso/graalvm-polyglot und https://github.com/accso/graalvm-native
Die GraalVM ist eine - gar nicht mal so neue - Java VM, die Schritt für Schritt immer mehr Produktionsreife und Popularität bei Entwicklern und Architekten gewinnt. Graal macht vor allem zwei Aspekte anders als die altbekannte HotspotVM:
Die Zukunft der JVM ist polyglott! Das wurde bereits mit Java 7 verkündet. Mit der GraalVM gewinnt viele Jahre später eine neue Java VM an Popularität, die sich ebenfalls das Thema polyglotte Programmierung auf die Fahne geschrieben hat.</description></item><item><title>16.06.2021: Why Don't They Just...?! The Deliberations Behind Evolving Java</title><link>http://jugf.github.io/posts/why-dont-they-just-evolving-java-16-06-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:56 +0100</pubDate><guid>http://jugf.github.io/posts/why-dont-they-just-evolving-java-16-06-2021/</guid><description>Update 18.06.
Die Slides zum Vortrag sind hier: https://slides.nipafx.dev/just/2021-06-16-jug-ffm Rabattcode (20%) zu Accento am 28./29.09. in Karlsruhe https://accento.dev: AccJUGFFM21 There are many nifty features that Java could have but doesn&amp;rsquo;t. Somewhat surprisingly, there are reasons for that and in this talk I&amp;rsquo;ll discuss those for a few concrete cases as well as the deliberations behind such decisions.
There are many nifty features that Java could have but doesn&amp;rsquo;t. Why, though, how hard can it be to implement them?</description></item><item><title>26.05.2021: GraalVM 21 Feature Update der universellen VM</title><link>http://jugf.github.io/posts/graalvm-21-feature-update-der-universellen-vm-26-05-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:55 +0100</pubDate><guid>http://jugf.github.io/posts/graalvm-21-feature-update-der-universellen-vm-26-05-2021/</guid><description>Update 28.05.: Die Folien zum Vortrag sind hier: 20210526_Weigend_GraalVM_21
Die GraalVM ist eine universelle Virtuelle Maschine (VM) für Anwendungen, die in JavaScript, Python, Ruby, R oder mit den JVM-basierten Programmiersprachen Java, Scala, Kotlin, Clojure und LLVM-basierten Sprachen C/C++ geschrieben wurden. Im April 2021 wurde die GraalVM 21.1.0 freigegeben, mit Performance-Verbesserungen und polyglotter Unterstützung für verschiedene Programmiersprachen und sie ermöglicht damit die Interoperabilität in einer gemeinsamen Laufzeitumgebung. GraalVM kann eigenständig oder im Kontext von OpenJDK, Node.</description></item><item><title>29.04.2021: Wie gut kennst Du das Collections Framework?</title><link>http://jugf.github.io/posts/wie-gut-kennst-du-das-collections-framework-29-04-2021/</link><pubDate>Mon, 11 Jan 2021 10:40:52 +0100</pubDate><guid>http://jugf.github.io/posts/wie-gut-kennst-du-das-collections-framework-29-04-2021/</guid><description>Update 03.05.: Die Folien zum Vortrag sind hier: 20210429_Frotscher-Collections-Framework.pdf
HashMap und ArrayList kennt jeder, na klar. Aber wann stellen sie eigentlich die richtige Wahl dar? Und vor allem: Wann nicht? Das Collections Framework enthält zahlreiche, zum Teil recht spezialisierte Implementierungen, doch viele Entwickler kennen nur einen kleinen Teil davon. Schon mal was von EnumSet oder WeakHashMap gehört? Und was ist eigentlich der Unterschied zwischen ConcurrentSkipListMap und ConcurrentHashMap? Je nachdem, welche konkreten Anforderungen jeweils umzusetzen sind, ist es wichtig, die Stärken und Schwächen der einzelnen Implementierungen zu kennen.</description></item><item><title>31.03.2021: Resilient Software Design Patterns</title><link>http://jugf.github.io/posts/resilient-software-design-patterns-31-03-2021/</link><pubDate>Mon, 11 Jan 2021 10:39:03 +0100</pubDate><guid>http://jugf.github.io/posts/resilient-software-design-patterns-31-03-2021/</guid><description>Update 01.04.: Die Folien zum Vortrag sind hier: Resilience_Patterns_JUGF_2021.pdf
Die Zeiten in denen eine Anwendung aus einem einzelnen großen Artefakt besteht, scheinen vorbei zu sein. Unter anderem im Zuge der verstärkten Containerisierung mit Docker &amp;amp; Co wird es immer beliebter, Anwendungen aus mehreren möglichst unabhängigen Artefakten zusammenzustellen, die über Prozessgrenzen miteinander kommunizieren. Diese Architektur ermöglicht eine schnellere Weiterentwicklung und eine elastische Anpassung an wechselnde Lastanforderungen. Falls nun eine Vielzahl an kleineren Anwendungen eine gemeinsame Aufgabe erfüllen sollen, wird ein fehlerfreies Gesamtsystem allerdings zunehmend unwahrscheinlicher.</description></item><item><title>24.02.2021: Blockchain Indizierung mit Apache Storm</title><link>http://jugf.github.io/posts/blockchain-indizierung-mit-apache-storm-24-02-2021/</link><pubDate>Sun, 10 Jan 2021 15:34:33 +0100</pubDate><guid>http://jugf.github.io/posts/blockchain-indizierung-mit-apache-storm-24-02-2021/</guid><description>Update 27.02.: Die Folien zum Vortrag sind hier: 20210224_blockchain_storm.pdf, das Github Repo zu den Sourcen ist https://github.com/jondoe1337/storm-example
Dezentrale Blockchains - Zentral indizieren? Zwei konträre Konzepte miteinander zu vereinen gab es sicher schon oft, dennoch besteht bei diesen beiden Konzepten noch das Problem der Datenmenge und Echtzeitanforderungen im Raum. Mit Apache Storm wurde eine flexible und schnelle Abarbeitung der Informationen die aktuelle Blockchains emittieren ermöglicht und schafft es als Bindeglied verschiedene Technologien einfach zu verbinden.</description></item><item><title>27.01.2021: Das Java Quiz - Was ihr schon immer über Java wußtet, aber euch niemand fragen wollte.</title><link>http://jugf.github.io/posts/das-java-quiz-27-01-2021/</link><pubDate>Tue, 22 Dec 2020 21:10:48 +0100</pubDate><guid>http://jugf.github.io/posts/das-java-quiz-27-01-2021/</guid><description>Update 28.01.: Die Folien zum Quiz sind hier: 20210127_JUGF_Java11_Quiz.pdf
Wie gut kennt ihr euch wirklich in der Java-Welt aus? Mit einer Auswahl von Fragen aus verschiedensten Quellen quer durch das Java-Beet wollen wir das herausfinden. Die Fragen entbehren nicht einer gewissen Knifflizität, könnten einem aber trotzdem im Entwickleralltag über den Weg laufen. Um der Lebensrealität der Mehrheit der Java-Entwickler gerecht zu werden, ist Java 11 die Basis für das Quiz.</description></item><item><title>JUGFs New Home</title><link>http://jugf.github.io/posts/jugfs-new-home/</link><pubDate>Tue, 22 Dec 2020 13:39:39 +0100</pubDate><guid>http://jugf.github.io/posts/jugfs-new-home/</guid><description>Bye Bye Google Sites Leider wird Google Sites, mit dem auch die bestehende jugf.de-Seite erstellt wurde, neu aufgesetzt, mobile-first, responsive usw. usf. Das ist sicherlich sinnvoll, leider werden &amp;ldquo;Bestandskunden&amp;rdquo; bei der Migration nicht wirklich unterstützt. Die automatische Migration auf das neue Format macht das Layout (noch) unbenutzbar(er).
Wir wollen uns nicht beschweren, das damalige Aufsetzen war sehr einfach und der Betrieb war die ganze Zeit über - also nun mehr als 10 Jahre - kostenlos und unproblematisch.</description></item></channel></rss>